

poln(pn)=v=binary(pn);l=length(v);sum(i=1,l,v[i]*x^(l-i))

for(i=1,100,pn=2^16 + 2*i + 1; pf=poln(pn);if( polisirreducible( Mod(1,2)*pf ), printf("%X  ", pn);print(pf)))

---


Summary,

We note that bit complexity of recovering x in AIM-1/3/5 is lower than key search circuit for AES-128/192/256. Since inversion of AIM is equivant to solving the AIMer secret key from the public key, the security of AIMer does not seem to meet the claims.

Similar observations have been made in [1], which presents an algebraic attack that sheds 2^13,2^14,2^15 from operations against AIM-1/3/5. I'd estimate that the security of AIMer falls short by 16-20 bits.

[1] Fukang Liu, Mohammad Mahzoun, Morten Ã˜ygarden, Willi Meier, "Algebraic Attacks on RAIN and AIM Using Equivalent Representations." IACR ePrint 2023/1133 https://eprint.iacr.org/2023/1133


Background

AIMer is a first-round PQC on-ramp candidate that builds a signature scheme from a symmetric one-way function (named AIM) and a non-interactive zero-knowledge proof of knowledge (NIZKPoK) system based on the MPC-in-the-Head paradigm. 

AIMer Public key consists is a pair pk = (iv, c) where "c" is output of the one-way function c = AIM(x, iv). The secret key is the quantity x (which is, slightly confusingly, "plaintext" in the context of the AIM function.). 

A direct way of breaking AIMer is to attack one-wayness: Solving the secret key x, given (iv, c) from the public key. There is no need to consider the NIZKPoK scheme in this type of attack; one simply determines the secret key and then constructs forgeries using the standard signing procedure.


Brief description of AIM

Let n in {128,192,256} be the security level for AIM-I/III/V. This is also the secret key "x" size. AIM uses binary fields size of F = GF(2^n).

Finite field exponentiation function Mer[e](x) = x^(2^e-1) is the only non-linear component in the algorithm. Internally, "iv" uses SHAKE to derive affine transforms: two or three invertible n*n binary matrices A1,A2(,A3) and an n-bit  vector / field element "b". However, the complexity of SHAKE does not affect the compexity of "x" search -- the affine transform can be considered to be a constant.

In the following '+' is a field addition (XOR), '^' is exponentiation, '*' is a binary vector-matrix multiplication . The AIM one-way functions are:

AIM-1: c = ( (x^(2^3-1))*A1 + (x^(2^27-1))*A2 + b )^(2^5-1) + x
AIM-3: c = ( (x^(2^5-1))*A1 + (x^(2^29-1))*A2 + b )^(2^7-1) + x
AIM-5: c = ( (x^(2^3-1))*A1 + (x^(2^53-1))*A2 + (x^(2^7-1))*A3 + b)^(2^5-1) + x

In terms of symmetric cryptography, AIM could be characterized as a 2-round SPN PRF.

Simple Key Search Manipulations
 
Recall that in a binary field we have (x+y)^2 = x^2 + y^2 and squaring is bitwise linear. Hence repeated squaring (i.e. computing x^(2^n)) is also linear. We use "Ei" matrices to represent power-of-2 exponentiations; x*Ei = x^(2^i) and  x*EMi = x^(-2^i) = x^(2^(n-i)).

Substitute z = x^-1. We can then turn the nonlinear exponentiations into a single simpler multiplications: Mer[e](x) = Ee*z.

In case of AIM-1, the search of "x" satisfying
	c == ( (x^(2^3-1))*A1 + (x^(2^27-1))*A2 + b )^(2^5-1) + x

.. can be transformed to remove all exponentiation operations ..
	u = x*E3*z*A1 + x*E27*z*A2 + b
	u*E5 == (c + x)*u

This makes making the circuit size much smaller. One generates x and z=x^-1 at the same time using a generator and its inverse (both are generated by LFSRs.)


